<title></title>
<script type="text/javascript">
var bname;
var bversion;
var req_submit;
// Get the x position of the mouse event.
function GetEventPosX(event) {
	if (IsNetscape()) return event.layerX;
	if (IsMicrosoft()) return event.x + document.getElementById('main_image').scrollLeft; //offsetX;
	return event.offsetX;
}
// Get the y position of the mouse event.
function GetEventPosY(event) {
	if (IsNetscape()) return event.layerY;
	if (IsMicrosoft()) return event.y + document.getElementById('main_image').scrollTop; //offsetY;
	return event.offsetY;
}
function GetBrowserInfo() {
	bname = navigator.appName;
	if (IsMicrosoft()) {
		var arVersion = navigator.appVersion.split("MSIE");
		bversion = parseFloat(arVersion[1]);
	}
	else if (IsNetscape() || IsSafari()) {
		bversion = parseInt(navigator.appVersion);
		//check for Safari.  
		if (navigator.userAgent.match('Safari')) bname = 'Safari';
	}
	else bversion = 0;
}
function IsNetscape() {
	return (bname.indexOf("Netscape") != -1);
}
function IsMicrosoft() {
	return (bname.indexOf("Microsoft") != -1);
}
function IsSafari() {
	return (bname.indexOf("Safari") != -1);
}
function IsChrome() {
	return (bname.indexOf("chrome") != -1);
}
</script>
<script type="text/javascript">
// image class
// Fetches and manipulates the main image that will be annotated.
// From the HTML code, create a <img src...> tag with an id and pass
// this id in as the argument when creating the class.
function webimage(id) {
	this.page_in_use = 0; // Describes if we already see an image.
	this.dir_name = null;
	this.im_name = null;
	this.id = id;
	this.im = document.getElementById(this.id);
	this.width_orig;
	this.height_orig;
	this.width_curr; //current width and height of the image itself
	this.height_curr;
	this.im_ratio; // Ratio of (displayed image dims) / (orig image dims)
	this.browser_im_ratio; // Initial im_ratio; this should not get changed!!
	this.curr_frame_width; // Current width of main_image.
	this.curr_frame_height; // Current height of main_image.
	// Parses the URL and gets the collection, directory, and filename
	// information of the image to be annotated.  Returns true if the
	// URL has collection, directory, and filename information.
	this.ParseURL = function () {
		var source_url = document.URL;
		var idx = source_url.indexOf('?');
		if ((idx != -1) && (this.page_in_use == 0)) {
			this.page_in_use = 1;
			var par_str = source_url.substring(idx + 1, source_url.length);
			do {
				idx = par_str.indexOf('&');
				var par_tag;
				if (idx == -1) par_tag = par_str;
				else par_tag = par_str.substring(0, idx);
				var par_field = this.GetURLField(par_tag);
				var par_value = this.GetURLValue(par_tag);
				if (par_field == 'folder') this.dir_name = par_value;
				else if (par_field == 'image') {
					this.im_name = par_value;
					if (this.im_name.indexOf('.jpg') == -1 && this.im_name.indexOf('.png') == -1) this.im_name = this.im_name + '.jpg';
				}
				par_str = par_str.substring(idx + 1, par_str.length);
			} while (idx != -1);
			if ((!this.dir_name) || (!this.im_name)) {
				return 0;
				//return this.SetURL(source_url);
			}
			document.getElementById('body').style.visibility = 'visible';
		}
		else {
			return 0;
			//return this.SetURL(source_url);
		}
		return 1;
	};
	// String is assumed to have field=value form.  Parses string to
	// return the field.
	this.GetURLField = function (str) {
		var idx = str.indexOf('=');
		return str.substring(0, idx);
	};
	// String is assumed to have field=value form.  Parses string to
	// return the value.
	this.GetURLValue = function (str) {
		var idx = str.indexOf('=');
		return str.substring(idx + 1, str.length);
	};
	// Fetches a new image based on the URL string or gets a new one at
	// random from the dirlist.  onload_helper is a pointer to a helper
	// function that is calld when the image is loaded.  Typically, this
	// will call obj.SetImageDimensions().
	this.GetNewImage = function (onload_helper) {
		document.getElementById('loading').style.display = '';
		if (IsMicrosoft()) this.im.style.visibility = 'hidden';
		else this.im.style.display = 'none';
        
        /*
        // for url link
		if (!this.ParseURL()) return; 
		this.im.src = 'Images/' + this.dir_name + '/' + this.im_name;
        */
        //for MTurk
        this.im.src = 'http://labelme2.csail.mit.edu/Release3.0/Images/users/nshreyasvi///satelliteimages/new.jpg';
        
		this.im.onload = onload_helper;
	};
	// Returns the ratio of the available width/height to the original
	// width/height.
	this.GetImRatio = function () {
		return this.im_ratio;
	};
	// If (x,y) is not in view, then scroll it into view.  Return adjusted
	// (x,y) point that takes into account the slide offset.
	this.SlideWindow = function (x, y) {
		var pt = Array(2);
		if (!this.IsPointVisible(x, y)) {
			document.getElementById('main_image').scrollLeft = x - 100;
			document.getElementById('main_image').scrollTop = y - 100;
		}
		pt[0] = x - document.getElementById('main_image').scrollLeft;
		pt[1] = y - document.getElementById('main_image').scrollTop;
		return pt;
	};
	//tells the picture to take up the available 
	//space in the browser, if it needs it. 6.29.06 
	this.ScaleFrame = function () {
		var mainImage = document.getElementById('main_image');
		//look at the available browser height and the image height,
		//and use the smaller of the two for the main_image height.
		var avail_height = this.GetAvailHeight();
		if (this.height_curr > avail_height) this.curr_frame_height = avail_height;
		else this.curr_frame_height = this.height_curr;
		//likewise for width
		var avail_width = this.GetAvailWidth();
		if (this.width_curr > avail_width) this.curr_frame_width = avail_width;
		else this.curr_frame_width = this.width_curr;
		mainImage.style.width = this.curr_frame_width + 'px';
		mainImage.style.height = this.curr_frame_height + 'px';
	};
	// Retrieves and sets the original image's dimensions (width/height).
	this.SetOrigImDims = function (im) {
		//7.12.06 Safari image dimensions fix
		if (IsSafari()) {
			var url = im.src;
			var img = new Image;
			img.src = url;
			img.visibility = 'hidden';
			img.display = 'none';
			this.width_orig = img.width;
			this.height_orig = img.height;
		}
		else {
			this.width_orig = im.width;
			this.height_orig = im.height;
		}
	};
	//gets available height
	this.GetAvailHeight = function () {
		return document.getElementById('main_section').offsetHeight;
	};
	//gets available width
	this.GetAvailWidth = function () {
		return document.getElementById('main_section').offsetWidth;
	};
	// Sets the dimensions of the image based on browser setup.
	this.SetImageDimensions = function () {
		this.SetOrigImDims(this.im);
		var avail_width = this.GetAvailWidth();
		var avail_height = this.GetAvailHeight();
		var width_ratio = avail_width / this.width_orig;
		var height_ratio = avail_height / this.height_orig;
		if (width_ratio < height_ratio) this.im_ratio = width_ratio;
		else this.im_ratio = height_ratio;
		this.browser_im_ratio = this.im_ratio;
		this.width_curr = Math.round(this.im_ratio * this.width_orig);
		this.height_curr = Math.round(this.im_ratio * this.height_orig);
		this.im.width = this.width_curr;
		this.im.height = this.height_curr;
		document.getElementById('myCanvas_bg').setAttribute('width', this.width_curr);
		document.getElementById('myCanvas_bg').setAttribute('height', this.height_curr);
		document.getElementById('myCanvas_fg').setAttribute('width', this.width_curr);
		document.getElementById('myCanvas_fg').setAttribute('height', this.height_curr);
		document.getElementById('myCanvas_tmp').setAttribute('width', this.width_curr);
		document.getElementById('myCanvas_tmp').setAttribute('height', this.height_curr);
		this.curr_frame_width = this.width_curr;
		this.curr_frame_height = this.height_curr;
		document.getElementById('loading').style.visibility = 'hidden';
		document.getElementById('main_image').style.visibility = 'visible';
		if (IsMicrosoft()) {
			this.im.style.visibility = '';
			document.getElementById('main_image').style.overflow = 'visible';
			this.ScaleFrame();
		}
		else this.im.style.display = '';
	};
	// Returns true if the image is zoomed to the original (fitted) resolution.
	this.IsFitImage = function () {
		return (this.im_ratio == this.browser_im_ratio);
	};
	// Returns true if (x,y) is viewable.
	this.IsPointVisible = function (x, y) {
		var scrollLeft = document.getElementById('main_image').scrollLeft;
		var scrollTop = document.getElementById('main_image').scrollTop;
		if (((x * this.im_ratio < scrollLeft) || (x * this.im_ratio - scrollLeft > this.curr_frame_width - 160)) || ((y * this.im_ratio < scrollTop) || (y * this.im_ratio - scrollTop > this.curr_frame_height))) return false; //the 160 is about the width of the right-side div
		return true;
	};
}
</script><script type="text/javascript">
var main_canvas;
var main_image;
function MainInit() {
	main_canvas = new webcanvas();
	main_image = new webimage('im');
	function main_image_onload_helper() {
		main_image.SetImageDimensions();
	};
	main_image.GetNewImage(main_image_onload_helper);
}
// Button Event
function OnUndoButton() {
	main_canvas.EraseSegmentButton();
}
function OnDrawButton() {
	if (main_canvas.edit_mode != DRAW_CANVAS) {
		main_canvas.edit_mode = DRAW_CANVAS;
		if (main_canvas.selected_id >= 0) {
			if (main_canvas.annotations[main_canvas.selected_id].is_selected) {
				//draw in myCanvas_bg
				main_canvas.annotations[main_canvas.selected_id].DrawPolygon(main_image.GetImRatio());
				main_canvas.annotations[main_canvas.selected_id].is_selected = 0;
				main_canvas.annotations[main_canvas.selected_id].UnfillPolygon();
				main_canvas.annotations[main_canvas.selected_id].RemoveControlPoints();
				main_canvas.selected_id = -1;
			}
		}
	}
}
function OnSelectButton() {
	if (main_canvas.edit_mode != SEL_CANVAS) {
		main_canvas.edit_mode = SEL_CANVAS;
		if (main_canvas.draw_anno) {
			main_canvas.draw_anno.DelPrevDashLine();
			main_canvas.draw_anno.DeletePolygon();
			main_canvas.draw_anno = null;
		}
	}
}
function OnDeleteButton() {
	main_canvas.EraseSelectedPolygon();
}
function gup( name )
{
	name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
	var regexS = "[\\?&]"+name+"=([^&#]*)";
	var regex = new RegExp( regexS );
	var results = regex.exec( window.location.href );
	if( results == null )
		return "";
	else
		return results[1];
}
function updateSubmitButton() {
	isAccepted = ( gup('assignmentId') != 'ASSIGNMENT_ID_NOT_AVAILABLE' );
	isCompleted = ( main_canvas.annotations.length >= ${MinAcceptNumber} ); //set how many annotation you want here 
	if ( !isAccepted && !isCompleted ) {
		document.getElementById('submitButton').disabled = 'disabled';
		document.getElementById('submitButton').value = 'accepth the HIT and complete the task before you can submit';
	}
	if ( isAccepted && isCompleted ) {
		document.getElementById('submitButton').disabled = '';
		document.getElementById('submitButton').value = 'submit';
	}
	if ( isAccepted && !isCompleted ) {
		document.getElementById('submitButton').disabled = 'disabled';
		document.getElementById('submitButton').value = 'complete the task before you can submit';
	}
	if ( !isAccepted && isCompleted ) {
		document.getElementById('submitButton').disabled = 'disabled';
		document.getElementById('submitButton').value = 'accept the HIT before you can work and submit';
	}
}
</script></p>

<h2>DrawMe Demo</h2>

<p><b>Instruction:</b> Put instruction for labeling here. You are required to label at least ${MinAcceptNumber} polygons/rectangles before you can submit.</p>

<div>Mode: <a href="javascript:OnDrawButton();" title="Draw polygon on canvas">Drawing</a> <a href="javascript:OnSelectButton();" title="Edit polygon on canvas">Editing</a> Operation: <a href="javascript:OnUndoButton();" title="Undo last control point">Delete Last Control Point</a> <a href="javascript:OnDeleteButton();" title="Delete selected polygon">Delete Selected Polygon</a></div>

<div id="main_section" style="position: relative; left: 0px; top: 0px; width: 500px; height: 500px;">
<div id="loading">Loading image...</div>

<div id="main_image" oncontextmenu="javascript:return false;" onmousedown="main_canvas.OnMouseDown(event);return false;" onmousemove="main_canvas.OnMouseMove(event);return false;" onmouseup="main_canvas.OnMouseUp(event);return false;" style="visibility: hidden; overflow: auto;"><img id="im" style="position: absolute; left: 0px; top: 0px; vertical-align: bottom; z-index: -3; visibility: visible" /> <canvas height="500" id="myCanvas_bg" style="position: absolute; left: 0px; top: 0px; z-index: 0; cursor: default;" width="500"> </canvas> <canvas height="500" id="myCanvas_tmp" style="position: absolute; left: 0px; top: 0px; z-index: 1; cursor: default;" width="500"></canvas> <canvas height="500" id="myCanvas_fg" style="position: absolute; left: 0px; top: 0px; z-index: 2; cursor: default;" width="500"> </canvas></div>
</div>

<div id="submitForm"><input autocomplete="off" disabled="disabled" id="submitButton" type="submit" value="accepth the HIT and complete the task before you can submit" />
<p>If you have any questions about this HIT, encounter a problem, or have suggestions on how we could improve it, please let us know: <input autocomplete="off" name="comment" style="width: 100%;" type="text" value="Put your OPTIONAL comments here" /></p>

<p><span style="font-size: 75%;">By making judgments about these tasks, you are participating in a study being performed by <b>XXX</b>. If you have questions about this research, please contact XXX at XXX@XXX.XXX. Your participation in this research is voluntary. You may decline to answer any or all of the questions. You may decline further participation, at any time, without adverse consequences. Your anonymity is assured; the researchers who have requested your participation will not receive any personal information about you. XXX owns all copyright of the result for your participation. </span></p>
<input autocomplete="off" id="labelData" name="labelData" type="hidden" value="" /></div>

